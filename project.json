[
  {
    "Path": "/home/zedolph/project-zero/catls",
    "Kind": "dir",
    "Size": 4096,
    "Depth": 0,
    "Content": "",
    "Ignored": false,
    "Error": ""
  },
  {
    "Path": "/home/zedolph/project-zero/catls/cmd",
    "Kind": "dir",
    "Size": 4096,
    "Depth": 1,
    "Content": "",
    "Ignored": false,
    "Error": ""
  },
  {
    "Path": "/home/zedolph/project-zero/catls/cmd/root.go",
    "Kind": "file",
    "Size": 2383,
    "Depth": 2,
    "Content": "package cmd\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/spf13/cobra\"\n\t\"catls/internal\"\n)\n\n// Config holds runtime options\ntype Config struct {\n\tPath        string\n\tMaxDepth    int\n\tMaxSize     int64\n\tOutputMode  string\n\tIgnore      []string\n\tSummary     bool\n\tOutputFile  string\n\tShowContent bool\n\tLines       int\n}\n\nvar cfg Config\n\nvar rootCmd = \u0026cobra.Command{\n\tUse:   \"catls [path]\",\n\tShort: \"catls merges cat + ls to serialize structure and content\",\n\tLong: `catls recursively walks directories, reading both structure and file contents\nto produce AI-friendly Markdown or JSON output.`,\n\tArgs: cobra.ExactArgs(1),\n\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\tcfg.Path = args[0]\n\n\t\t// Determine if full content is needed (JSON always includes full content)\n\t\tfullContent := cfg.OutputMode == \"json\"\n\n\t\t// Scan filesystem\n\t\tentries, err := internal.ScanDir(cfg.Path, cfg.MaxDepth, cfg.Ignore, cfg.ShowContent, cfg.Lines, fullContent)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Summary-only mode\n\t\tif cfg.Summary {\n\t\t\tfor _, e := range entries {\n\t\t\t\tfmt.Printf(\"[%s] %s (%d bytes, depth=%d)\\n\", e.Kind, e.Path, e.Size, e.Depth)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\t// Format output\n\t\toutput, err := internal.FormatEntries(entries, internal.FormatMode(cfg.OutputMode))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Write to file or stdout\n\t\tif cfg.OutputFile != \"\" {\n\t\t\treturn os.WriteFile(cfg.OutputFile, []byte(output), 0644)\n\t\t} else {\n\t\t\tfmt.Print(output)\n\t\t}\n\n\t\treturn nil\n\t},\n}\n\n// Execute bootstraps CLI\nfunc Execute() {\n\tif err := rootCmd.Execute(); err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n}\n\nfunc init() {\n\trootCmd.Flags().IntVar(\u0026cfg.MaxDepth, \"max-depth\", -1, \"Limit recursion depth\")\n\trootCmd.Flags().Int64Var(\u0026cfg.MaxSize, \"max-size\", 64000, \"Max bytes per file\")\n\trootCmd.Flags().StringVar(\u0026cfg.OutputMode, \"format\", \"markdown\", \"Output format: markdown or json\")\n\trootCmd.Flags().StringSliceVar(\u0026cfg.Ignore, \"ignore\", []string{\".git\", \"node_modules\"}, \"Ignore patterns\")\n\trootCmd.Flags().BoolVar(\u0026cfg.Summary, \"summary\", false, \"Structure only, no content\")\n\trootCmd.Flags().StringVar(\u0026cfg.OutputFile, \"output\", \"\", \"Write output to file instead of stdout\")\n\trootCmd.Flags().BoolVar(\u0026cfg.ShowContent, \"show-content\", false, \"Show file content preview in Markdown\")\n\trootCmd.Flags().IntVar(\u0026cfg.Lines, \"lines\", 5, \"Number of lines to preview if --show-content is true\")\n}",
    "Ignored": false,
    "Error": ""
  },
  {
    "Path": "/home/zedolph/project-zero/catls/go.mod",
    "Kind": "file",
    "Size": 182,
    "Depth": 1,
    "Content": "module catls\n\ngo 1.24.2\n\nrequire (\n\tgithub.com/inconshreveable/mousetrap v1.1.0 // indirect\n\tgithub.com/spf13/cobra v1.10.1 // indirect\n\tgithub.com/spf13/pflag v1.0.10 // indirect\n)",
    "Ignored": false,
    "Error": ""
  },
  {
    "Path": "/home/zedolph/project-zero/catls/go.sum",
    "Kind": "file",
    "Size": 985,
    "Depth": 1,
    "Content": "github.com/cpuguy83/go-md2man/v2 v2.0.6/go.mod h1:oOW0eioCTA6cOiMLiUPZOpcVxMig6NIQQ7OS05n1F4g=\ngithub.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=\ngithub.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=\ngithub.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/spf13/cobra v1.10.1 h1:lJeBwCfmrnXthfAupyUTzJ/J4Nc1RsHC/mSRU2dll/s=\ngithub.com/spf13/cobra v1.10.1/go.mod h1:7SmJGaTHFVBY0jW4NXGluQoLvhqFQM+6XSKD+P4XaB0=\ngithub.com/spf13/pflag v1.0.9/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/spf13/pflag v1.0.10 h1:4EBh2KAYBwaONj6b2Ye1GiHfwjqyROoF4RwYO+vPwFk=\ngithub.com/spf13/pflag v1.0.10/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=",
    "Ignored": false,
    "Error": ""
  },
  {
    "Path": "/home/zedolph/project-zero/catls/internal",
    "Kind": "dir",
    "Size": 4096,
    "Depth": 1,
    "Content": "",
    "Ignored": false,
    "Error": ""
  },
  {
    "Path": "/home/zedolph/project-zero/catls/internal/filter.go",
    "Kind": "file",
    "Size": 16,
    "Depth": 2,
    "Content": "package internal",
    "Ignored": false,
    "Error": ""
  },
  {
    "Path": "/home/zedolph/project-zero/catls/internal/formatter.go",
    "Kind": "file",
    "Size": 2058,
    "Depth": 2,
    "Content": "package internal\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n// FormatMode defines supported output types\ntype FormatMode string\n\nconst (\n\tMarkdown FormatMode = \"markdown\"\n\tJSON     FormatMode = \"json\"\n)\n\n// FormatEntries formats a list of FileEntry into Markdown or JSON\nfunc FormatEntries(entries []FileEntry, mode FormatMode) (string, error) {\n\tswitch mode {\n\tcase Markdown:\n\t\treturn formatMarkdown(entries), nil\n\tcase JSON:\n\t\treturn formatJSON(entries)\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"unsupported format: %s\", mode)\n\t}\n}\n\n// ------------------- Markdown -------------------\n\nfunc formatMarkdown(entries []FileEntry) string {\n\tvar sb strings.Builder\n\n\tfor _, e := range entries {\n\t\tif e.Kind == \"dir\" {\n\t\t\tsb.WriteString(fmt.Sprintf(\"\\n## üìÅ %s\\n\", e.Path))\n\t\t} else if e.Kind == \"file\" {\n\t\t\tsb.WriteString(fmt.Sprintf(\"\\n### üìÑ %s\\n\", e.Path))\n\t\t\tsb.WriteString(fmt.Sprintf(\"@type: file\\n@size: %d bytes\\n\", e.Size))\n\n\t\t\tlang := detectLanguage(e.Path)\n\t\t\tif lang != \"\" {\n\t\t\t\tsb.WriteString(fmt.Sprintf(\"@language: %s\\n\", lang))\n\t\t\t}\n\n\t\t\tif e.Content != \"\" {\n\t\t\t\tsb.WriteString(\"```\" + lang + \"\\n\")\n\t\t\t\tsb.WriteString(e.Content + \"\\n\")\n\t\t\t\tsb.WriteString(\"```\\n\")\n\t\t\t}\n\n\t\t\tsb.WriteString(\"---\\n\")\n\t\t}\n\t}\n\n\treturn sb.String()\n}\n\n// ------------------- JSON -------------------\n\nfunc formatJSON(entries []FileEntry) (string, error) {\n\tdata, err := json.MarshalIndent(entries, \"\", \"  \")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(data), nil\n}\n\n// ------------------- Helper -------------------\n\nfunc detectLanguage(path string) string {\n\tif dot := strings.LastIndex(path, \".\"); dot != -1 \u0026\u0026 dot \u003c len(path)-1 {\n\t\text := path[dot+1:]\n\t\tswitch ext {\n\t\tcase \"go\":\n\t\t\treturn \"go\"\n\t\tcase \"rs\":\n\t\t\treturn \"rust\"\n\t\tcase \"js\":\n\t\t\treturn \"javascript\"\n\t\tcase \"ts\":\n\t\t\treturn \"typescript\"\n\t\tcase \"py\":\n\t\t\treturn \"python\"\n\t\tcase \"java\":\n\t\t\treturn \"java\"\n\t\tcase \"c\":\n\t\t\treturn \"c\"\n\t\tcase \"cpp\":\n\t\t\treturn \"cpp\"\n\t\tcase \"html\":\n\t\t\treturn \"html\"\n\t\tcase \"css\":\n\t\t\treturn \"css\"\n\t\tcase \"md\":\n\t\t\treturn \"markdown\"\n\t\tdefault:\n\t\t\treturn \"\"\n\t\t}\n\t}\n\treturn \"\"\n}",
    "Ignored": false,
    "Error": ""
  },
  {
    "Path": "/home/zedolph/project-zero/catls/internal/scanner.go",
    "Kind": "file",
    "Size": 2714,
    "Depth": 2,
    "Content": "package internal\n\nimport (\n\t\"bufio\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// FileEntry represents one filesystem entity.\ntype FileEntry struct {\n\tPath    string\n\tKind    string // \"file\" or \"dir\"\n\tSize    int64\n\tDepth   int\n\tContent string\n\tIgnored bool\n\tError   string\n}\n\n// ScanDir walks the directory recursively and returns entries.\n// showContent: preview for Markdown\n// lines: number of lines to preview\n// fullContent: if true, reads full file (used for JSON output)\nfunc ScanDir(root string, maxDepth int, ignore []string, showContent bool, lines int, fullContent bool) ([]FileEntry, error) {\n\tvar entries []FileEntry\n\n\trootAbs, _ := filepath.Abs(root)\n\n\terr := filepath.WalkDir(rootAbs, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\tentries = append(entries, FileEntry{Path: path, Error: err.Error()})\n\t\t\treturn nil\n\t\t}\n\n\t\t// Depth calculation\n\t\trel, err := filepath.Rel(rootAbs, path)\n\t\tif err != nil {\n\t\t\trel = path\n\t\t}\n\t\tdepth := 0\n\t\tif rel != \".\" {\n\t\t\tdepth = strings.Count(filepath.ToSlash(rel), \"/\") + 1\n\t\t}\n\n\t\tif maxDepth \u003e= 0 \u0026\u0026 depth \u003e maxDepth {\n\t\t\tif d.IsDir() {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\t// Ignore patterns\n\t\tfor _, ig := range ignore {\n\t\t\tif strings.Contains(path, ig) {\n\t\t\t\tif d.IsDir() {\n\t\t\t\t\treturn filepath.SkipDir\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tinfo, err := d.Info()\n\t\tif err != nil {\n\t\t\tentries = append(entries, FileEntry{Path: path, Error: err.Error()})\n\t\t\treturn nil\n\t\t}\n\n\t\tentry := FileEntry{\n\t\t\tPath:  path,\n\t\t\tKind:  kindFromDirEntry(d),\n\t\t\tSize:  info.Size(),\n\t\t\tDepth: depth,\n\t\t}\n\n\t\t// Read file content if requested\n\t\tif !d.IsDir() \u0026\u0026 info.Size() \u003e 0 {\n\t\t\treadFull := fullContent || showContent\n\t\t\tcontent, ok := readFileContent(path, lines, readFull)\n\t\t\tif ok {\n\t\t\t\tentry.Content = content\n\t\t\t}\n\t\t}\n\n\t\tentries = append(entries, entry)\n\t\treturn nil\n\t})\n\n\treturn entries, err\n}\n\nfunc kindFromDirEntry(d fs.DirEntry) string {\n\tif d.IsDir() {\n\t\treturn \"dir\"\n\t}\n\tif d.Type()\u0026fs.ModeSymlink != 0 {\n\t\treturn \"symlink\"\n\t}\n\treturn \"file\"\n}\n\n// readFileContent reads first n lines or full content based on 'full'\nfunc readFileContent(path string, n int, full bool) (string, bool) {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn \"\", false\n\t}\n\tdefer f.Close()\n\n\t// Skip binary files\n\tbuf := make([]byte, 8000)\n\tcount, _ := f.Read(buf)\n\tif strings.ContainsRune(string(buf[:count]), '\\x00') {\n\t\treturn \"\", false\n\t}\n\n\tf.Seek(0, 0) // rewind\n\n\tscanner := bufio.NewScanner(f)\n\tvar lines []string\n\n\tif full {\n\t\tfor scanner.Scan() {\n\t\t\tlines = append(lines, scanner.Text())\n\t\t}\n\t} else {\n\t\tfor i := 0; i \u003c n \u0026\u0026 scanner.Scan(); i++ {\n\t\t\tlines = append(lines, scanner.Text())\n\t\t}\n\t}\n\n\treturn strings.Join(lines, \"\\n\"), true\n}",
    "Ignored": false,
    "Error": ""
  },
  {
    "Path": "/home/zedolph/project-zero/catls/main.go",
    "Kind": "file",
    "Size": 76,
    "Depth": 1,
    "Content": "// main.go\npackage main\n\nimport \"catls/cmd\"\n\nfunc main() {\n\tcmd.Execute()\n}",
    "Ignored": false,
    "Error": ""
  },
  {
    "Path": "/home/zedolph/project-zero/catls/project.json",
    "Kind": "file",
    "Size": 1781,
    "Depth": 1,
    "Content": "[\n  {\n    \"Path\": \"/home/zedolph/project-zero/catls\",\n    \"Kind\": \"dir\",\n    \"Size\": 4096,\n    \"Depth\": 0,\n    \"Content\": \"\",\n    \"Ignored\": false,\n    \"Error\": \"\"\n  },\n  {\n    \"Path\": \"/home/zedolph/project-zero/catls/cmd\",\n    \"Kind\": \"dir\",\n    \"Size\": 4096,\n    \"Depth\": 1,\n    \"Content\": \"\",\n    \"Ignored\": false,\n    \"Error\": \"\"\n  },\n  {\n    \"Path\": \"/home/zedolph/project-zero/catls/cmd/root.go\",\n    \"Kind\": \"file\",\n    \"Size\": 2256,\n    \"Depth\": 2,\n    \"Content\": \"\",\n    \"Ignored\": false,\n    \"Error\": \"\"\n  },\n  {\n    \"Path\": \"/home/zedolph/project-zero/catls/go.mod\",\n    \"Kind\": \"file\",\n    \"Size\": 182,\n    \"Depth\": 1,\n    \"Content\": \"\",\n    \"Ignored\": false,\n    \"Error\": \"\"\n  },\n  {\n    \"Path\": \"/home/zedolph/project-zero/catls/go.sum\",\n    \"Kind\": \"file\",\n    \"Size\": 985,\n    \"Depth\": 1,\n    \"Content\": \"\",\n    \"Ignored\": false,\n    \"Error\": \"\"\n  },\n  {\n    \"Path\": \"/home/zedolph/project-zero/catls/internal\",\n    \"Kind\": \"dir\",\n    \"Size\": 4096,\n    \"Depth\": 1,\n    \"Content\": \"\",\n    \"Ignored\": false,\n    \"Error\": \"\"\n  },\n  {\n    \"Path\": \"/home/zedolph/project-zero/catls/internal/filter.go\",\n    \"Kind\": \"file\",\n    \"Size\": 16,\n    \"Depth\": 2,\n    \"Content\": \"\",\n    \"Ignored\": false,\n    \"Error\": \"\"\n  },\n  {\n    \"Path\": \"/home/zedolph/project-zero/catls/internal/formatter.go\",\n    \"Kind\": \"file\",\n    \"Size\": 2058,\n    \"Depth\": 2,\n    \"Content\": \"\",\n    \"Ignored\": false,\n    \"Error\": \"\"\n  },\n  {\n    \"Path\": \"/home/zedolph/project-zero/catls/internal/scanner.go\",\n    \"Kind\": \"file\",\n    \"Size\": 2445,\n    \"Depth\": 2,\n    \"Content\": \"\",\n    \"Ignored\": false,\n    \"Error\": \"\"\n  },\n  {\n    \"Path\": \"/home/zedolph/project-zero/catls/main.go\",\n    \"Kind\": \"file\",\n    \"Size\": 76,\n    \"Depth\": 1,\n    \"Content\": \"\",\n    \"Ignored\": false,\n    \"Error\": \"\"\n  }\n]",
    "Ignored": false,
    "Error": ""
  }
]